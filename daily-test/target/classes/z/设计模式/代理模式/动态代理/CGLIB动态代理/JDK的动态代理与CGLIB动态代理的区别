
区别：
        1.JDK的动态代理是基于接口实现，创建被代理对象实现接口的，如果没有继承接口的类怎没有办法实现动态代理
            这好像能解释为什么之前用@Cacheable的时候如果不是在接口实现类上使用时，就无法正确加入缓存的原因
        2.CGLIB则是基于类事项的，创建被代理类的子类实现切面的，所以如果每个类被final修饰之后，也无法再使用CGLIB的动态代理

效率上的差异
        1.JDK的动态代理在运行效率上，要低于CGLIB的效率，
        2.CGLIB的动态代理在创建效率上，有远远不如JDK的动态代理，

使用上的选择
        1.当代理对象时单例或者不需要频繁创建的时候，选择使用CGLIB的动态代理，反之使用JDK的动态代理